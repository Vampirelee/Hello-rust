# 字符串与文本

## 一些 Unicode 的背景知识

介绍一些 Unicode 的背景知识有助于更好地理解 Rust。

### ASCII、Latin-1、Unicode

ASCII 是最初的 7 位编码，它包含了 128 个字符，包括英文字母、数字、标点符号和一些控制字符。

Latin-1 扩展了 ASCII，增加了 128 个字符，包括西欧语言的字符。

Unicode 是为了解决不同语言、不同文化的字符编码问题而创建的。它包含了超过 100,000 个字符，涵盖了世界上所有语言和文化。

### UTF-8 编码

Rust 的 String 类型和 str 类型表示使用了 UTF-8 编码形式的文本。UTF-8 会将字符编码为 1~4 字节的序列，如图所示。

![](./images/1.png)

格式良好的 UTF-8 序列有两个限制。首先，只有任何给定码点的最短编码才被认为是格式良好的，你不能花费 4 字节来编码原本只需要 3 字节的码点。此规则确保了每个码点只会有唯一一个 UTF-8 编码。其次，格式良好的 UTF-8 不得对从 0xd800 到 0xdfff 或超过 0x10ffff 的数值进行编码:这些数值要么保留用作非字符目的，要么完全超出了 Unicode 的范围。

一些 UTF-8 的编码示例：

![](./images/2.png)

虽然在螃蟹表情符号的编码中其前导字节对码点只贡献了一串 0，但是它仍然需要用 4 字节来编码:3 字节的 UTF-8 编码只能表达 16 位码点，而 0x1f980 有 17 位长。

- 由于 UTF-8 会把码点 0 ~ 0x7f 编码为字节 0 ~ 0x7f，因此一段 ASCII 文本必然是有效的 UTF-8 字符串。反过来，如果 UTF-8 字符串中只包含 ASCII 字符，则它也必然是有效的 ASCII 字符串。

  > 对于 Latin-1 则不是这样的，比如，Latin-1 会将 é 编码为字节 0xe9，而 UTF-8 会将其解释为三字节编码中的第一字节

- 通过查看任何字节的高位，就能立刻判断出它是某个字符的 UTF-8 编码的起始字节还是中间字节

### 文本的方向性

拉丁文、西里尔文、泰文等文字是从左向右书写的，而希伯来文、阿拉伯文等文字则是从右向左书写的。Unicode 以写入或读取字符的常规顺序存储字符，因此在这种情况下字符串(如希伯来语文本)中保存的首字节是对写在最右端的字符的编码。

## 字符（char）

Rust 的 char 类型是一个包含 Unicode 码点的 32 位值。char 保证会落在 0~ 0xd7ff 或 0xe000~0x10ffff 范围内，所有用于创建和操作 char 值的方法都会确保此规则永远成立。char 类型实现了 Copy 和 Clone，以及用于比较、哈希和格式化的所有常用特型。

字符串切片可以使用 slice.chars() 生成针对其字符的迭代器:

```rust
assert_eq!("カニ".chars().next(), Some('カ'));
```

### 字符分类

char 类型的一些方法可以将字符分入几个常见类别

- ch.is_numeric() 判断是否为数字
- ch.is_alphabetic() 判断是否为字母
- ch.is_alphanumeric() 判断是否为字母或数字
- ch.is_whitespace() 判断是否为空白字符
- ch.is_control() 判断是否为控制字符

下面是一组仅限于 ASCII 的方法，对任何非 ASCII char 都会返回 false

- ch.is_ascii() 判断是否为 ASCII 字符，码点介于 0~127 之间
- ch.is_ascii_alphabetic() 判断是否为大写或小写 ASCII 字母，在'A'..='Z'或'a'..='z'之间
- ch.is_ascii_alphanumeric() 判断是否为 ASCII 字母或数字
- ch.is_ascii_digit() 判断是否为 ASCII 数字，在'0'..='9'之间
- ch.is_ascii_hexdigit() 判断是否为 ASCII 十六进制数字，在'0'..='9'或'a'..='f'或'A'..='F'之间
- ch.is_ascii_punctuation() 判断是否既不是字母也不是数字的任何 ASCII 图形字符
- ch.is_ascii_uppercase() 判断是否为大写 ASCII 字母，在'A'..='Z'之间
- ch.is_ascii_lowercase() 判断是否为小写 ASCII 字母，在'a'..='z'之间

> 所有 is*ascii*... 方法也可用于 u8 字节类型

### 处理数字

对于数字的处理，可以使用以下方法

- `ch.to_digit(radix)` 转数字

  判断 ch 是不是以 radix 为基数的数字。如果是，就返回 Some(num)，
  其中 num 是 u32；否则，返回 None。此方法只会识别 ASCII 数字，而不包括
  char::is_numeric 涵盖的更广泛的字符类别。radix 参数的范围可以从 2
  到 36。对于大于 10 的基数，会用 ASCII 字母（不分大小写）表示值为 10 到
  35 的数字。

- `std::char::from_digit(num, radix)` 来自数字

  自由函数，只要有可能，就可以把 u32 数字值 num 转换为 char。如果
  num 可以表示为 radix 中的单个数字，那么 from_digit 就会返回
  Some(ch)，其中 ch 是数字。当 radix 大于 10 时，ch 可以是小写字母。
  否则，它会返回 None。

- `ch.is_digit(radix)` 是数字？

  如果 ch 可以表示以 radix 为基数的 ASCII 数字，就返回 true。此方法
  等效于 ch.to_digit(radix) != None。

### 字符大小写转换

- `ch.to_lowercase()` 转换为小写字母，
- `ch.to_uppercase()` 转换为大写字母。

这两个方法会返回迭代器而不是单个字符，因为 Unicode 中的大小写转换并不总是一对一的过程

```rust
let mut upper = 's'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);

// 德文字母"ß"的大写形式是"SS"：
let mut upper1 = 'ß'.to_uppercase();
assert_eq!(upper1.next(), Some('S'));
assert_eq!(upper1.next(), Some('S'));
assert_eq!(upper1.next(), None);
```

> 这些迭代器都实现了 std::fmt::Display 特型，因此可以将它们直接传给 println! 或 write! 宏

### 与整数之间的转换

Rust 的 as 运算符会将 char 转换为任何整数类型，并抹掉高位

> as 是运算符！！！

```rust
assert_eq!('B' as u32, 66);
assert_eq!('饂' as u8, 66); // 截断高位
assert_eq!('二' as i8, -116); // 同上
```

as 运算符会将任何 u8 值转换为 char，并且 char 也实现了 `From<u8>`。但是，更宽的整数类型可以表示无效码点，因此对于那部分整数，必须使用`std::char::from_u32` 进行转换，它会返回 `Option<char>`。

```RUST
assert_eq!(char::from(66), 'B');
assert_eq!(std::char::from_u32(0x9942), Some('饂'));
assert_eq!(std::char::from_u32(0xd800), None); // 为UTF-16保留的码点
```

## String 与 str

Rust 的 String 类型和 str 类型会保证自己只包含格式良好的 UTF-8。标准库通过限制你创建 String 值和 str 值的方式以及可以对它们执行的操作来确保这一点。这样，当引入这些值时一定是格式良好的，而且在使用中也是如此。它们所有的方法都会坚守这个保证：对它们的任何安全操作都不会引入格式错误的 UTF-8。这就简化了处理文本的代码。

Rust 可以将文本处理方法关联到 str 或 String 上，具体关联到哪个取决于该方法是需要可调整大小的缓冲区还是仅满足于就地使用文本。由于 String 可以解引用成 &str，因此在 str 上定义的每个方法都可以直接在 String 上使用。

String 通过封装 `Vec<u8>` 实现，并可以确保向量中的内容永远是格式良好的 UTF-8。Rust 永远不会把 String 改成更复杂的表示形式，因此你可以假设 String 的性能表现始终会和 Vec 保持一致。

### 创建字符串值

创建 String 值的常见方法有以下几种

- `String::new()` 返回一个新的空字符串。这时还没有在堆上分配缓冲区，但将来会按需分配。

- `String::with_capacity(n)` 　返回一个新的空字符串，其中预先分配了一个足以容纳至少 n 字节的缓冲区。如果事先知道要构建的字符串的长度，则此构造函数可以让你从一开始就正确设置缓冲区大小，而不是等构建字符串时再进行调整。如果字符串的长度超过 n 字节，则该字符串仍会根据需要增加其缓冲区。与向量一样，字符串也有 capacity 方法、reserve 方法和 shrink_to_fit 方法，但一般来说默认的分配逻辑就很好。

- `str_slice.to_string()` 分配一个新的 String，其内容是 str_slice 的副本。

- `iter.collect()` 通过串联迭代器的各个条目构造出字符串，迭代器的条目可以是 char 值、&str 值或 String 值。

  ```rust
  let spacey = "man hat tan";
  let spaceless: String = spacey.chars().filter(|c| !c.is_whitespace()).collect();
  assert_eq!(spaceless, "manhattan");
  ```

### 简单探查

下面这些方法可以从字符串切片中获取基本信息。

- `slice.len()` 返回字符串的长度（以字节为单位）。

- `slice.is_empty()` 判断字符串是否为空。

- `slice[range]` 返回借用了 slice 给定部分的切片。有界的范围、部分有界的
  范围和无界的范围都可以。

  ```rust
  let full = "bookkeeping";
  assert_eq!(&full[..4], "book");
  assert_eq!(&full[5..], "eeping");
  assert_eq!(&full[2..4], "ok");
  assert_eq!(full[..].len(), 11);
  assert_eq!(full[5..].contains("boo"), false);
  ```

  请注意，不能索引具有单个位置的字符串切片，比如`slice[i]`。要想在给定的字节偏移处获取单个字符有点儿笨拙：必须在切片上生成一个 `chars` 迭代器，并要求它解析成单个字符的 `UTF-8`

- `slice.split_at(i)` 拆分于, 返回从 slice 借来的两个共享切片的元组：一个是字节偏移量 i 之前的部分，另一个是字节偏移量 i 之后的部分。换句话说，这会返回 `(slice[..i], slice[i..])`。

- `slice.is_char_boundary(i)` 是字符边界？如果字节偏移量 i 恰好落在字符边界之间并且适合作为 slice
  的偏移量，就返回 True。

### 追加文本与插入文本

- `string.push(ch)` 压入，将字符 ch 追加到 string 的末尾。

- `string.push_str(slice)` 压入字符串

- `string.extend(iter)` 以 iter 扩展, 将迭代器 iter 生成的条目追加到字符串中。迭代器可以生成 char 值、str 值或 String 值。这是 String 对 std::iter::Extend 特型的实现。

  ```rust
  let mut also_spaceless = "con".to_string();
  also_spaceless.extend("tri but ion".split_whitespace());
  assert_eq!(also_spaceless, "contribution");
  ```

- `string.insert(i, ch)` 插入于， 在 string 内的字节偏移量 i 处插入单个字符 ch。这需要平移 i 之后的所有字符以便为 ch 腾出空间，因此用这种方式构建字符串的时间复杂度是 O(n)。

- `string.insert_str(i, slice)` 插入字符串于

  String 实现了 std::fmt::Write，这意味着 write! 宏和 writeln! 宏可以将格式化后的文本追加到 String 上：

  ```rust
  use std::fmt::Write;
  let mut letter = String::new();
  writeln!(letter, "Whose {} these are I think I know", "rutabagas")?;
  writeln!(letter, "His house is in the village though;")?;
  assert_eq!(letter, "Whose rutabagas these are I think I know\nHis house is in the village though;\n");
  ```

  由于 write! 和 writeln! 是专为写入输出流而设计的，因此它们会返回一个 Result，如果你忽略 Result，则 Rust 会报错。上述代码使用了 ? 运算符来处理错误，但实际上写入 String 是肯定不会出错的，因此这种情况下也可以调用 .unwrap()。

String 实现了 `Add<&str>` 和 `AddAssign<&str>`，所以你可以编写如下代码

```rust
let left = "partners".to_string();
let mut right = "crime".to_string();
assert_eq!(left + " in " + &right, "partners in crime");
right += " doesn't pay";
assert_eq!(right, "crime doesn't pay");
```

当应用于字符串时，+ 运算符会按值获取其左操作数，所以实际上它可以重用该 String 的缓冲区作为加法的结果。因此，如果左操作数的缓冲区足够容纳结果，那么就不需要分配内存。

遗憾的是，此运算不是对称的，+ 的左操作数不能是 &str，所以不能写成：

```RUST
let parenthetical = "(" + string + ")";
```

只能改成

```rust
let parenthetical = "(".to_string() + &string + ")";
```

通过向末尾追加小片段的方式从头到尾构建字符串是高效的。String 的行为方式与向量是一样的，当它需要更多容量时，总是至少将其缓冲区大小加倍。这就令再次复制的开销与字符串的最终大小成正比。不过，使用`String::with_capacity` 创建具有正确缓冲区大小的字符串可以完全避免调整大小，并且可以减少对堆分配器的调用次数。

### 文本移除和替换

String 有以下几个移除文本的方法。这些方法不会影响字符串的容量，如果需要释放内存，请使用 shrink_to_fit。

- string.clear() 清空字符串。

- string.truncate(n) 截断字符串，使其长度为 n 字节。如果 n 小于等于当前长度，则截断到 n 字节；否则，截断到当前长度。

- string.pop() 移除并返回 string 的最后一个字符。如果 string 为空，则返回 None。

- string.remove(i) 移除并返回 string 内的字节偏移量 i 处的字符。这需要平移 i 之后的所有字符以便腾出空间，因此用这种方式构建字符串的时间复杂度是 O(n)。

- string.drain(range) 移除并返回 string 内的字节范围 range 内的字符。这需要平移 range 之后的所有字符以便腾出空间，因此用这种方式构建字符串的时间复杂度是 O(n)。

- string.replace_range(range, slice) 用 slice 替换 string 内的字节范围 range 内的字符。这需要平移 range 之后的所有字符以便腾出空间，因此用这种方式构建字符串的时间复杂度是 O(n)。

### 搜索与迭代的约定

Rust 用于搜索文本和迭代文本的标准库函数遵循了一些命名约定，以便于记忆。

- `r`

  大多数操作会从头到尾处理文本，但名称以 r 开头的操作会从尾到头处理。例如，rsplit 是 split 的从尾到头版本。

- `n`

  名称以 n 结尾的迭代器会将自己限定为只取给定数量的匹配项。

- `_indices`

  名称以 \_indices 结尾的迭代器会生成通常的迭代值和在此 slice 中的字节偏移量组成的值对。

### 搜索文本的模式

当标准库函数需要搜索、匹配、拆分或修剪文本时，它能接受如下几种类型来表示要查找的内容：

```rust
let haystack = "One fine day, in the middle of the night, I saw a shining star";

assert_eq!(haystack.find(","), Some(12));
assert_eq!(haystack.find("day"), Some(9));
assert_eq!(haystack.find(char::is_whitespace), Some(3));
```

这些类型称为模式，大多数操作支持它们。标准库支持 4 种主要的模式。

- 以 `char` 作为模式意味着要匹配该字符
- 以 `String`、`&str` 或 `&&str` 作为模式，意味着要匹配等于该模式的字串
- 以 `Fn(char) -> bool` 闭包作为模式，意味着要匹配满足该函数的任何字符
- 以 `&[char]` 注意并不是 &str，而是 char 的切片，作为模式，意味着要匹配该列表中出现的任何单个字符。请注意，如果将此列表写成数组字面量，那么可能要调用 as_ref() 来获得正确的类型, 如果不这么做，则 Rust 会误以为这是固定大小数组类型 `&[char; 2]`。遗憾的是，`&[char; 2]` 不是有效的模式类型。

### 搜索与替换

Rust 提供了一些可以在切片中搜索某些模式并可能将其替换成新文本的方法。

- slice.contains(pattern) 包含， 如果 slice 包含 pattern 的匹配项，就返回 true。

- slice.starts_with(pattern) 开头， 如果 slice 开头是 pattern 的匹配项，就返回 true。

- slice.ends_with(pattern) 结尾， 如果 slice 结尾是 pattern 的匹配项，就返回 true。

- slice.find(pattern) 查找， 返回 Some(i) 说明找到了匹配项，其中 i 是匹配项的字节偏移量。如果没有匹配项，则返回 None。

  ```rust
    let quip = "We also know there are known unknowns";
  assert_eq!(quip.find("know"), Some(8));
  assert_eq!(quip.rfind("know"), Some(31));
  assert_eq!(quip.find("ya know"), None);
  assert_eq!(quip.rfind(char::is_uppercase), Some(0));
  ```

- slice.replace(pattern, replacement) 替换, 返回新的 String，它是通过用 replacement 急性替换 pattern 的所有匹配项而形成的

- slice.replacen(pattern, replacement, n) 替换 n 次,与上一个方法类似，但最多替换前 n 个匹配项。
