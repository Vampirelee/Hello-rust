# 字符串与文本

## 一些 Unicode 的背景知识

介绍一些 Unicode 的背景知识有助于更好地理解 Rust。

### ASCII、Latin-1、Unicode

ASCII 是最初的 7 位编码，它包含了 128 个字符，包括英文字母、数字、标点符号和一些控制字符。

Latin-1 扩展了 ASCII，增加了 128 个字符，包括西欧语言的字符。

Unicode 是为了解决不同语言、不同文化的字符编码问题而创建的。它包含了超过 100,000 个字符，涵盖了世界上所有语言和文化。

### UTF-8 编码

Rust 的 String 类型和 str 类型表示使用了 UTF-8 编码形式的文本。UTF-8 会将字符编码为 1~4 字节的序列，如图所示。

![](./images/1.png)

格式良好的 UTF-8 序列有两个限制。首先，只有任何给定码点的最短编码才被认为是格式良好的，你不能花费 4 字节来编码原本只需要 3 字节的码点。此规则确保了每个码点只会有唯一一个 UTF-8 编码。其次，格式良好的 UTF-8 不得对从 0xd800 到 0xdfff 或超过 0x10ffff 的数值进行编码:这些数值要么保留用作非字符目的，要么完全超出了 Unicode 的范围。

一些 UTF-8 的编码示例：

![](./images/2.png)

虽然在螃蟹表情符号的编码中其前导字节对码点只贡献了一串 0，但是它仍然需要用 4 字节来编码:3 字节的 UTF-8 编码只能表达 16 位码点，而 0x1f980 有 17 位长。

- 由于 UTF-8 会把码点 0 ~ 0x7f 编码为字节 0 ~ 0x7f，因此一段 ASCII 文本必然是有效的 UTF-8 字符串。反过来，如果 UTF-8 字符串中只包含 ASCII 字符，则它也必然是有效的 ASCII 字符串。

  > 对于 Latin-1 则不是这样的，比如，Latin-1 会将 é 编码为字节 0xe9，而 UTF-8 会将其解释为三字节编码中的第一字节

- 通过查看任何字节的高位，就能立刻判断出它是某个字符的 UTF-8 编码的起始字节还是中间字节

### 文本的方向性

拉丁文、西里尔文、泰文等文字是从左向右书写的，而希伯来文、阿拉伯文等文字则是从右向左书写的。Unicode 以写入或读取字符的常规顺序存储字符，因此在这种情况下字符串(如希伯来语文本)中保存的首字节是对写在最右端的字符的编码。

## 字符（char）

Rust 的 char 类型是一个包含 Unicode 码点的 32 位值。char 保证会落在 0~ 0xd7ff 或 0xe000~0x10ffff 范围内，所有用于创建和操作 char 值的方法都会确保此规则永远成立。char 类型实现了 Copy 和 Clone，以及用于比较、哈希和格式化的所有常用特型。

字符串切片可以使用 slice.chars() 生成针对其字符的迭代器:

```rust
assert_eq!("カニ".chars().next(), Some('カ'));
```

### 字符分类

char 类型的一些方法可以将字符分入几个常见类别

- ch.is_numeric() 判断是否为数字
- ch.is_alphabetic() 判断是否为字母
- ch.is_alphanumeric() 判断是否为字母或数字
- ch.is_whitespace() 判断是否为空白字符
- ch.is_control() 判断是否为控制字符

下面是一组仅限于 ASCII 的方法，对任何非 ASCII char 都会返回 false

- ch.is_ascii() 判断是否为 ASCII 字符，码点介于 0~127 之间
- ch.is_ascii_alphabetic() 判断是否为大写或小写 ASCII 字母，在'A'..='Z'或'a'..='z'之间
- ch.is_ascii_alphanumeric() 判断是否为 ASCII 字母或数字
- ch.is_ascii_digit() 判断是否为 ASCII 数字，在'0'..='9'之间
- ch.is_ascii_hexdigit() 判断是否为 ASCII 十六进制数字，在'0'..='9'或'a'..='f'或'A'..='F'之间
- ch.is_ascii_punctuation() 判断是否既不是字母也不是数字的任何 ASCII 图形字符
- ch.is_ascii_uppercase() 判断是否为大写 ASCII 字母，在'A'..='Z'之间
- ch.is_ascii_lowercase() 判断是否为小写 ASCII 字母，在'a'..='z'之间

> 所有 is*ascii*... 方法也可用于 u8 字节类型

### 处理数字

对于数字的处理，可以使用以下方法

- `ch.to_digit(radix)` 转数字

  判断 ch 是不是以 radix 为基数的数字。如果是，就返回 Some(num)，
  其中 num 是 u32；否则，返回 None。此方法只会识别 ASCII 数字，而不包括
  char::is_numeric 涵盖的更广泛的字符类别。radix 参数的范围可以从 2
  到 36。对于大于 10 的基数，会用 ASCII 字母（不分大小写）表示值为 10 到
  35 的数字。

- `std::char::from_digit(num, radix)` 来自数字

  自由函数，只要有可能，就可以把 u32 数字值 num 转换为 char。如果
  num 可以表示为 radix 中的单个数字，那么 from_digit 就会返回
  Some(ch)，其中 ch 是数字。当 radix 大于 10 时，ch 可以是小写字母。
  否则，它会返回 None。

- `ch.is_digit(radix)` 是数字？

  如果 ch 可以表示以 radix 为基数的 ASCII 数字，就返回 true。此方法
  等效于 ch.to_digit(radix) != None。

### 字符大小写转换

- `ch.to_lowercase()` 转换为小写字母，
- `ch.to_uppercase()` 转换为大写字母。

这两个方法会返回迭代器而不是单个字符，因为 Unicode 中的大小写转换并不总是一对一的过程

```rust
let mut upper = 's'.to_uppercase();
assert_eq!(upper.next(), Some('S'));
assert_eq!(upper.next(), None);

// 德文字母"ß"的大写形式是"SS"：
let mut upper1 = 'ß'.to_uppercase();
assert_eq!(upper1.next(), Some('S'));
assert_eq!(upper1.next(), Some('S'));
assert_eq!(upper1.next(), None);
```

> 这些迭代器都实现了 std::fmt::Display 特型，因此可以将它们直接传给 println! 或 write! 宏

### 与整数之间的转换

Rust 的 as 运算符会将 char 转换为任何整数类型，并抹掉高位

> as 是运算符！！！

```rust
assert_eq!('B' as u32, 66);
assert_eq!('饂' as u8, 66); // 截断高位
assert_eq!('二' as i8, -116); // 同上
```

as 运算符会将任何 u8 值转换为 char，并且 char 也实现了 `From<u8>`。但是，更宽的整数类型可以表示无效码点，因此对于那部分整数，必须使用`std::char::from_u32` 进行转换，它会返回 `Option<char>`。
```RUST
assert_eq!(char::from(66), 'B');
assert_eq!(std::char::from_u32(0x9942), Some('饂'));
assert_eq!(std::char::from_u32(0xd800), None); // 为UTF-16保留的码点
```