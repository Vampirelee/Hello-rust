# Rust 的基础数据类型

## 1. 固定宽度的数值类型

rust 中数值类型的名称都遵循着统一的模式，也就是以“位”数表示它们的宽度，以前缀表明它们的用途。

**表：Rust 数值类型**
|大小(位)|无符号整数|有符号整数|浮点数｜
|---|---|---|---|
|8|u8|i8||
|16|u16|i16||
|32|u32|i32|f32|
|64|u64|i64|f64|
|128|u128|i128||
|机器字|usize|isize||

## 2. 整型

Rust 中的整型和 C++的类似，一共有以下几类：`u8`、`u16`、 `u32`、`u64`、`u128`、`uzise`。

Rust 会使用 `u8`类型作为字节值，例如，从二进制文件或者套接字中读取数据时会产生一个 `u8`值构成的流。

与 C/C++不同，Rust 会把字符视为与数值截然不同的类型：`char`既不是`u8`，也不是`u32`。

`usize`和`isize`类型类似于 C/C++ 中的 `size_t`和`ptrdiff_t`。它们的精度与目标机器上地址空间的大小保持一致。对于现在的计算机来说，通常是 64 位。即`u64`。Rust 要求数组索引是`usize`值。用来表示数组或向量大小或某些数据结构中元素数量的值通常也是`usize`类型。

Rust 中的整型字面量可以带上一个后缀来指示它们的类型：`42u8`表示数字 42 是`u8`类型而不是其他整型类型。`1729isize`是类型为`isize`的数字 1729。如果整型字面量没有指定类型后缀，那么 Rust 就会延迟确定其类型，直到找出一处足以认定其类型的使用代码，比如存储在特定类型的变量中、传给期待特定类型的函数、与具有特定类型的另一个值进行比较。如果有多种候选类型，那么 Rust 就会默认使用`i32`(如果此类型是候选类型之一的话)。如果无法认定类型，那么 Rust 就会将此歧义报告为错误。

在 Rust 中，为了方便数字的读取，可以在数字（十进制、八进制、十六进制以及二进制都可以）之间任意插入下划线。例如，可以`u32`的最大值写成`4_294_967_295`。也可以分隔开数字的类型后缀。如`127_u8`。

尽管数字类型和 char 类型是不同的。但 Rust 为 `u8`提供了**字节字面量**。
`b'X'`表示已字符 X 的 ASCII 码作为 u8 的值。由于 A 的 ASCII 码是 65。因此字面量`b'A'`和 `65u8`是完全等效的。有几个特殊的字符不能简单地放在单引号后面。

| 字符         | 字节字面量 | 等效数值 |
| ------------ | ---------- | -------- |
| 单号号 (')   | b'\\''     | 38u8     |
| 反斜杆 (\\)  | b'\\\\'    | 92u8     |
| 换行 (lf)    | b'\n'      | 10u8     |
| 回车 (cr)    | b'\\r'     | 13u8     |
| 制表符 (tab) | b'\\t'     | 9u8      |

标准库提供了一些方法，可以像整型的方法一样使用。如：

```rust
assert_eq!(2_u16.pow(4), 16) // 求幂
assert_eq!(-4_i32.abs(), 4) // 求绝对值
```

在实际编码中，可以不写出类型后缀，因为编译器会根据上下文将决定其类型。但是，如果编译器不能推断其类型时，**将会报错**，如：

```rust
println!("{}", (-4).abs());
//将会报错： can't call method `abs` on ambiguous numeric type `{integer}`
```

注意，方法的优先级高于一元运算法。所有 `(-4).abs()`必须要加负号。否则结果将是-4.

### 2.1 检查算法、回绕算法、饱和算法和溢出算法

当整型算术运算溢出时，Rust 在调试构建中会出现 panic（Rust 的一种错误警告）。而在发布构建中，运算会**回绕**：它生成的值等于“数字意义上正确的结果”对“值类型范围”取模的值（而不是像 C/C++那样出现“溢出为定义”的行为）。

```rust
// 以下代码在调试构建中会出现 panic：
let mut i = 1;
loop {
    i *= 10; // 试图进行可能溢出的乘法（但只会在调试构建中出现）
}

```

如果这种默认的行为不是你想要的，则整型提供的某些方法可以让你准确地阐明自己期望的行为。

```rust
// 以下代码在任意构建中都会出现 panic
let mut i: i32 = 1;
loop {
    i = i.checked_mul(10).expect("multiplication overflowed");
}
```

整型算术方法分为这 4 大类：

- **检查运算**(以`checked_`开头)会返回结果的 `Option`值：如果数学意义上正确的结果可以表示为该类型的值，那么就为`Some(v)`, 否则为`None`.

```rust
// 10与20之和可以表示为 u8
assert_eq!(10_u8.checked_add(20), Some(30));

// 100和200之和不能表示为u8
assert_eq!(100_u8.checked_add(200), None);

// 做加法，如果溢出，则会出现 panic
let sum = x.checked_add(y).unwrap();

// 奇怪的是，在某种特殊情况下， 带符号的除法也会溢出，带符号的 n 位类型可以表示 -2^n - 1，但是不能表示 2 ^n -1
assert_eq!((-128_i8).checked_div(-1), None);
```

- **回绕运算**(以`wrapping_`开头)会返回与“数学意义上正确的结果”对“值类型范围”取模的值相等的值。
- **饱和运算**(以`saturation__`开头)会返回最接近“数学意义上正确的结果”的可表达值。换句话说，结果“紧贴着”该类型可表达的最大值和最小值. 不存在 饱和除法、饱和求余法、或饱和位移法。

```rust
assert_eq!(32760_i16.saturating_add(10), 32767);
```

- **溢出运算**(以`overflowing_`开头)会返回一个元组(result, overflowed),其中 result 是函数的回绕版本所返回的内容，而 overflowed 是一个布尔值，指示是否发生过溢出。

```rust
assert_eq!(5_u16.overflowing_shl(17), (10, true));
```

前缀`checked_`、`wrapping_`、`saturating_`、`overflowing_`可以跟着的运算名称如表:
|运算|名称后缀|例子|  
|-|-|-|
|加法|add|100_i8.checked_add(27) == Some(127)|
|减法|sub|10_u8.checked_sub(11) == None|
|乘法|mul|128_u8.saturating_mul(3) == 255|
|除法|div|64_u16.wrapping_div(8) == 8|
|求余|rem|(-32768_i16).wrapping_rem(-1) == 0|
|取负|neg|(-128_i8).checked_neg() == None|
|绝对值|abs|(-32768_i16).wrapping_abs() == None|
|求幂|pow|3_u8.checked_pow(4) == Some(81)|
|按位左移|shl |10_u32.wrapping_shl(34) == 40|
|按位右移|shr|40_u64.wrapping_shr(66)==10|

## 3. 浮点类型

Rust 同样也提供了 IEEE 的单精度和双精度这两种浮点类型。这些类型包括正无穷大、负无穷大、不同的正零值和负零值，以及非数值(NaN)

字面量浮点数一般由以下几个部分组成，以 `3145.926e-4f64`为例。
其中`3145`是整数部分，`.926`是浮点部分。`e-4`是指数部分。`f64`为类型后缀。

为了便于类型推断， Rust 会将整型字面量和浮点字面量视为不同的大类。它永远不会把整型字面量推断为浮点类型。反之亦然。

```rust
// 下面的语句会报错
let a: i32 = 2.0;
// expected `i32`, found floating-point number
```

f32 和 f64 具有 IEEE 要求的一些特殊值的关联常量。比如：INFINITY、NEG_INFINITY、NAN、以及 MIN 和 MAX。这些都以 f32::和 f64::开头。

```rust
assert_eq!(-f32::MIN, f32::MAX);
```

浮点类型也提供了完备的数学计算方法，比如 `2f64.sqrt()`就是 2 的双精度平方根。

```rust
assert_eq!(5f32.sqrt() * 5f32.sqrt(), 5.0);
```

模块 `std::f32::consts`和`std::f64::consts`提供了各种常用的数学常量，比如`E`、`PI`和 2 的平方根。

与 C/C++不同，Rust 几乎不会执行任何隐式的数值转换。如果函数参数需要`f64`类型，则传入`i32`型参数是错误的。只能使用`as`进行隐式转换。例如:`3.0 as f64`

```rust
fn add(a: f64, b:f64)->f64 {
    a + b
}
...

let a:f32 = 1.0
// 此语句会报错，因为参数类型不匹配
add(a, a);
```

## 4. 布尔类型

Rust 在 if 语句和 while 语句这样的控制结构要求它们的条件必须是 bool 表达式（其他语言，可能进行隐士转换，比如 js 中，0 和空串会被视为 false），短路逻辑运算符 && 和 ||也同样如此，非常严格。必须写成 `if x != 0 {...}`,而不能只写成 `if x {...}`。

## 5. 字符

Rust 的字符类型 char 会以 32 位值表示耽搁 Unicode 字符，但对字符串和文本流使用 UTF-8 编码。因为，String 会将其文本表示为 UTF-8 字节序列，而不是字符数组。

字符字面量是用**单引号**括起来的字符，比如 '8' 或 '!',还可以直接使用单个汉字，比如 '我'。这在 C/C++中是行不通的。

同样，Rust 不会在 char 和任何其他类型之间进行隐式转换。可以使用 as 转换运算符将 char 转换为整型。对于小于 32 位的类型，该字符值的高位会被截断。

反过来来看，u8 是唯一能通过 as 运算符转换为 char 的类型，因为 Rust 刻意让 as 运算符只执行开销极低且可靠的转换，但是除了 u8 之外的每个整型都可能包含 Unicode 码点之外的值，所以这些转换都要做运行期检查。作为替代方案，标准库函数 std::char::from_u32 可以接受任何 u32 值并返回一个 Option<char>, 如果此 u32 不是允许的 Unicode 码点，那么 from_u32 机会返回 Node，否则，它会返回 Some(c)，其中 c 是转换成 char 后的结果。

标准库为字符提供了一些有用的方法，可以在 char 和模块 std::char 下的在线文档中找到这些方法

## 6. 元组

元组是各种类型值的值对或三元组、四元组、五元组（因此成为 n-元组或元组）。

可以将元组编写为一个元素序列，用逗号隔开并包裹在一对圆括号中。例如， `("hello world", 1995)`是一个元组，其第一个元素是一个静态分配的字符串，第二个元素是一个整数，它的类型是`($str, i32)`。给定一个元组值 t，可以通过`t.0`、`t.1`等方式访问其元素。

元组有点类似于数组，即这两种类型都表示值的有序序列。许多编程语言混用或结合了这两个概念，如 typescript。但是在 Rust 中，数组和元组是截然不同的。一方面，元组的每个元素可以有不同的类型，而数组的元素必须都是相同的类型。另一方面，元组只允许用常量作为索引，比如, `t.4`。不同通过写成 `t.i`或者`t[i]`的形式来获取第 i 个元素（i 是运行时获取的）。

Rust 代码通常会用元组类型从一个函数返回多个值。例如，字符串切片上的 split_at 方法会讲字符串分成两半并返回它们。

```rust
fn split_at(&self, mid: usize) -> (&str, &str);
```

返回类型`(&str, &str)`是两个字符串切片构成的元组。可以用模式匹配语法将返回值的每个元素赋值给不同的变量：

```rust
let text = "I see the eigenvalue in thine eye";
let (head, tail) = text.split_at(21);
assert_eq!(head, "I see the eigenvalue ");
assert_eq!(tail, "in thine eye");
```

还有一种常见的元组类型是零元组 `()`。传统上，这叫做 单元类型，因为此类型只有一个值，写作`()`。当无法携带任何有意义的值但其上下文仍然要求传入某种类型时，Rust 就会使用单元类型。

不返回值的函数的返回类型为`()`。这和其他编程不太一样，js 会返回 undefiened。C/C++会返回 void；

如果你愿意，可以在元组的最后一个元素之后跟上一个逗号。类型`(&str, i32)`和`(&str, i32,)`是等效的。Rust 始终允许在所有能用逗号的地方，比如，函数参数、数组、结构体和枚举定义。为了保持一致性，甚至有包含单个值的元组，它的类型是`(&str,)`。在这里，值后面的逗号是必须的，用于区分单值元组和简单的括号表达式。

## 7. 指针类型

Rust 有多种表示内存地址的类型。这和其他绝大数具有垃圾回收功能的语言之间一个重大的差异。

### 7.1 引用

引用是用`&`修饰的，`&String`类型的值是对 String 值的引用，`&i32`是对`i32`的引用，以此类推。

最简单的方式是将引用视为 Rust 中的基本指针类型。在运行期间，对 `i32`对引用是一个保存着 `i32`地址对机器字，这个地址可能位于栈或者堆中。表达式`&x`会生成一个对`x`的引用。给定一个引用`r`，表达式`*r`会引用`r`指向定值。它们非常像 C/C++中的 `&`运算符和`*`运算符，并且和 C 中的指针一样，当超出作用域时引用不会自动释放任何资源。

在 Rust 中的引用永远不会为空，在安全的 Rust 中根本没有办法生成空引用。与 C 不同，Rust 会跟踪值的所有权和生命周期，因此早在编译期间就排除了悬空指针、双重释放和指针失效等错误。

Rust 引用有两种形式

- `&T`: 一个不可变得共享引用。你可以同时拥有多个对给定值的共享引用，但它们是只读的，也就是禁止修改它们所指向的值，就像 C 语言 中的 `const T*`一样

- `&mut T`: 一个可变的、独占的引用。你可以读取和修改它指向的值，就像 C 语言中的 `T*`一样。但是只要该引用还存在，就不能对该值有任何类型的其他引用。事实上，访问该值的唯一途径就是使用这个可变引用。

Rust 利用共享引用和可变引用过之间“二选一”机制来强制执行“单个写入者或多个读取者”规则：你要么独占读写一个值，要么让任意数量的读取者共享，但二者只能选择其一。这种规则是 Rust 安全保障的核心。

### 7.2 Box

在堆中分配值的最简单方式是使用 `Box::new`:

```rust
let t = (12, "eggs");
let b = Box::new(t); // 在堆中分配一个元组
```

对`Box::new`的调用会分配足够的内存以在堆上容纳此元组。当 `b`超出作用域时，内存会立即被释放，除非`b`已被移动（比如返回它）。

### 7.3 裸指针

Rust 也有裸指针类型`*mut T`和`*const T`。裸指针实际上和 C++ 中的指针很像。使用裸指针是不安全的，因为 Rust 不会跟踪它指向的内容。比如，裸指针可能为空，或者它们可能指向已释放的内存或者现在包含不同类型的值。

但是，你可以在 unsafe 块中对裸指针的解引用。 unsafe 块是 Rust 高级语言特性中的可选机制，其安全性取决于你自己。

## 8. 数组、向量和切片

Rust 用 3 种类型来表示内存中值序列。

- 类型`[T; N]`表示 N 个值的数组，每个值的类型为 `T`。数组的大小是在编译期间就已经确定的常量，并且是类型的一部分，不能追加新元素或缩小数组。
- 类型`Vec<T>`称为 T 的向量，它是一个动态分配且可增长的 T 类型的值序列。向量的元素存在于堆中，因此可以随意调整向量大小：压入新元素、追加其他向量、删除元素等。
- 类型`&[T]`和`&mut [T]`称为 T 的**共享切片**和 T 的**可变切片**，它们是对一系列元素的引用，这些元素是某个其他值（比如数组或向量）的一部分。可以将切片视为指向其第一个元素的指针，以及从该点开始允许访问的元素数量的计数。可变切片 `&mut[T]`允许读取元素和修改元素，但不能共享；共享切片`&[T]`允许在多个读取者之间共享访问权限，但不允许修改元素。

### 8.1 数组

编写数组值的方法有好几种，其中最简单的方法是在方括号内写入一系列值：

```rust
let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];
let taxonomy = ["Animalia", "Arthropoda", "Insecta"];

assert_eq!(lazy_caterer[3], 7);
assert_eq!(taxonomy.len(), 3);
```

对于要填充一些值的长数组的常见情况，可以写成`[V; N]`, 其中 `V`是每个元素的值，`N`是长度。例如，`[true, 10000]`是一个包含 10000 个 bool 元素的数组，其内容全为 `true`：

```rust
let mut sieve = [true; 10000];
for i in 2..100 {
    let mut j = i * i;
    while j < 10000 {
        sieve[j] = false;
        j += i;
    }
}

assert!(sieve[211]);
assert!(sieve[9876]);
```

在这里，我们看到了声明固定大小缓冲区的语法：`[0u8; 1024]`, 它是一个 1kb 的缓冲区，用 0 填充。 Rust 没有任何能定义未初始化数组的写法。一般来说, Rust 会确保代码永远无法访问任何种类的未初始化值。

数组的长度是其类型的一部分，并会在编译期间固定下来。如果 n 是变量，则不能写成 `[true; n]`以期望得到一个包涵 n 个元素的数组。当我们需要一个长度在运行期间可变的数组时，请使用向量。

我们在数组看到的一些实用方法（便利元素、搜索、排序、填充、过滤等）都是作为切片而非数组的方法提供的。但是 Rust 在搜索各种方法时会隐式地对数组的引用转换为切片，因此可以直接在数组上调用任何切片方法：

```rust
let mut chaos = [3, 5, 4, 1, 2];
chaos.sort();
assert_eq!(chaos, [1, 2, 3, 4, 5])
```

在这里，`sort` 方法实际上是在切片上定义的，但由于它是通过引用获取的操作目标，因此 Rust 会隐式地生成一个引用整个数组的 `&mut[i32]`切片，并将其传给 sort 来进行操作。

### 8.2 向量

向量 `Vec<T>`是一个可调整大小的 T 类型元素的数组，它是在堆上分配的。

创建向量有以下几种

- 使用`vec!`宏， 相当于调用`Vec::new`来创建一个新的空向量，然后将元素压入其中，这是另一种惯用法;

```rust
// 使用 vec! 宏
let mut primes = vec![2, 3, 5, 7];
// 相当于以下代码
let mut pal = Vec::new();
pal.push(2);
pal.push(3);
pal.push(5);
pal.push(7);

// 还可以通过将给定值重复来构建向量，模仿数组字面量的语法
fn new_pixel_buffer(rows: usize, cols: usize) -> Vec<u8> {
  vec![0; rows * cols]
}
```

- 从迭代器生成的值构成一个向量

```rust
let v: Vec<i32> = (0..5).collect();
assert_eq!(v, [0, 1, 2, 3, 4]);
```

向量和数组一样，可以对向量使用切片的方法：

```rust
let mut palindrome = vec!["a man", "a plan", "a canal", "panama"];
palindrome.reverse();

assert_eq!(palindrome, vec!["panama", "a canal", "a plan", "a man"]);
```

在这里， reverse 方法实际上是切片上面定义的，但是此调用会隐式地从此向量中借用一个 `&mut [&str]`切片并在其上调用 reverse。

向量由以下 3 个值组成

- 指向元素在堆中分配的缓冲区的指针
- 缓冲区能够存储的元素数量
- 现在实际包含的元素数量

当缓冲区达到其最大容量时，往向量中添加另一个元素需要分配一个更大的缓冲区，将当前内容复制到其中，更新向量的指针和容量以指向新缓冲区，最后释放旧缓冲区。

如果我们事先知道向量所需要的元素数量，就可以调用`Vec::with_capacity`而不是`Vec::new`来创建一个向量。这样可以避免重新分配等一系列工作。

向量的 `len` 方法会返回它现在包含的元素数，而 `capacity` 方法则会返回在不重新分配的情况下可以容纳的元素数：

```rust
let mut v = Vec::with_capacity(2);
assert_eq!(v.len(), 0);
assert_eq!(v.capacity(), 2);

v.push(1);
v.push(2);

assert_eq!(v.len(), 2);
assert_eq!(v.capacity(), 2);

v.push(3);
assert_eq!(v.len(), 3);
// 通常会打印出"capacity is now 4"
println!("capacity is now {}", v.capacity());
```

对向量的插入和移除元素方法，其时间复杂度是 O(n)

### 8.3 切片

切片是数组或向量中的一个区域。由于切片可以是任意长度，因此它不能直接存储在变量中或作为函数参数进行传递。_切片总是通过引用传递的_。

对切片的引用是一个胖指针：一个双字值，包括指向切片第一个元素的指针和切片中元素的数量。

如果要写一个对数组或向量进行操作的函数，那么切片引用就是第一选择。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5, 6, 7];
    print_splice(&a[0..5]);
}
fn print_splice(n: &[i32]) {
    for elt in n {
        println!("{}", elt);
    }
}
```

最常见的两个切片： `&[T]`和`&str`，一个切片数组，一个是切片字符串
