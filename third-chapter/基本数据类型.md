# Rust 的基础数据类型

## 1. 固定宽度的数值类型

rust 中数值类型的名称都遵循着统一的模式，也就是以“位”数表示它们的宽度，以前缀表明它们的用途。

**表：Rust 数值类型**
|大小(位)|无符号整数|有符号整数|浮点数｜
|---|---|---|---|
|8|u8|i8||
|16|u16|i16||
|32|u32|i32|f32|
|64|u64|i64|f64|
|128|u128|i128||
|机器字|usize|isize||

## 2. 整型

Rust 中的整型和 C++的类似，一共有以下几类：`u8`、`u16`、 `u32`、`u64`、`u128`、`uzise`。

Rust 会使用 `u8`类型作为字节值，例如，从二进制文件或者套接字中读取数据时会产生一个 `u8`值构成的流。

与 C/C++不同，Rust 会把字符视为与数值截然不同的类型：`char`既不是`u8`，也不是`u32`。

`usize`和`isize`类型类似于 C/C++ 中的 `size_t`和`ptrdiff_t`。它们的精度与目标机器上地址空间的大小保持一致。对于现在的计算机来说，通常是 64 位。即`u64`。Rust 要求数组索引是`usize`值。用来表示数组或向量大小或某些数据结构中元素数量的值通常也是`usize`类型。

Rust 中的整型字面量可以带上一个后缀来指示它们的类型：`42u8`表示数字 42 是`u8`类型而不是其他整型类型。`1729isize`是类型为`isize`的数字 1729。如果整型字面量没有指定类型后缀，那么 Rust 就会延迟确定其类型，直到找出一处足以认定其类型的使用代码，比如存储在特定类型的变量中、传给期待特定类型的函数、与具有特定类型的另一个值进行比较。如果有多种候选类型，那么 Rust 就会默认使用`i32`(如果此类型是候选类型之一的话)。如果无法认定类型，那么 Rust 就会将此歧义报告为错误。

在 Rust 中，为了方便数字的读取，可以在数字（十进制、八进制、十六进制以及二进制都可以）之间任意插入下划线。例如，可以`u32`的最大值写成`4_294_967_295`。也可以分隔开数字的类型后缀。如`127_u8`。

尽管数字类型和 char 类型是不同的。但 Rust 为 `u8`提供了**字节字面量**。
`b'X'`表示已字符 X 的 ASCII 码作为 u8 的值。由于 A 的 ASCII 码是 65。因此字面量`b'A'`和 `65u8`是完全等效的。有几个特殊的字符不能简单地放在单引号后面。

| 字符         | 字节字面量 | 等效数值 |
| ------------ | ---------- | -------- |
| 单号号 (')   | b'\\''     | 38u8     |
| 反斜杆 (\\)  | b'\\\\'    | 92u8     |
| 换行 (lf)    | b'\n'      | 10u8     |
| 回车 (cr)    | b'\\r'     | 13u8     |
| 制表符 (tab) | b'\\t'     | 9u8      |

标准库提供了一些方法，可以像整型的方法一样使用。如：

```rust
assert_eq!(2_u16.pow(4), 16) // 求幂
assert_eq!(-4_i32.abs(), 4) // 求绝对值
```

在实际编码中，可以不写出类型后缀，因为编译器会根据上下文将决定其类型。但是，如果编译器不能推断其类型时，**将会报错**，如：

```rust
println!("{}", (-4).abs());
//将会报错： can't call method `abs` on ambiguous numeric type `{integer}`
```

注意，方法的优先级高于一元运算法。所有 `(-4).abs()`必须要加负号。否则结果将是-4.

## 3. 检查算法、回绕算法、饱和算法和溢出算法

当整型算术运算溢出时，Rust 在调试构建中会出现 panic（Rust 的一种错误警告）。而在发布构建中，运算会**回绕**：它生成的值等于“数字意义上正确的结果”对“值类型范围”取模的值（而不是像 C/C++那样出现“溢出为定义”的行为）。

```rust
// 以下代码在调试构建中会出现 panic：
let mut i = 1;
loop {
    i *= 10; // 试图进行可能溢出的乘法（但只会在调试构建中出现）
}

```

如果这种默认的行为不是你想要的，则整型提供的某些方法可以让你准确地阐明自己期望的行为。

```rust
// 以下代码在任意构建中都会出现 panic
let mut i: i32 = 1;
loop {
    i = i.checked_mul(10).expect("multiplication overflowed");
}
```

整型算术方法分为这 4 大类：

- **检查运算**(以`checked_`开头)会返回结果的 `Option`值：如果数学意义上正确的结果可以表示为该类型的值，那么就为`Some(v)`, 否则为`None`.

```rust
// 10与20之和可以表示为 u8
assert_eq!(10_u8.checked_add(20), Some(30));

// 100和200之和不能表示为u8
assert_eq!(100_u8.checked_add(200), None);

// 做加法，如果溢出，则会出现 panic
let sum = x.checked_add(y).unwrap();

// 奇怪的是，在某种特殊情况下， 带符号的除法也会溢出，带符号的 n 位类型可以表示 -2^n - 1，但是不能表示 2 ^n -1
assert_eq!((-128_i8).checked_div(-1), None);
```

- **回绕运算**(以`wrapping_`开头)会返回与“数学意义上正确的结果”对“值类型范围”取模的值相等的值。
- **饱和运算**(以`saturation__`开头)会返回最接近“数学意义上正确的结果”的可表达值。换句话说，结果“紧贴着”该类型可表达的最大值和最小值. 不存在 饱和除法、饱和求余法、或饱和位移法。

```rust
assert_eq!(32760_i16.saturating_add(10), 32767);
```

- **溢出运算**(以`overflowing_`开头)会返回一个元组(result, overflowed),其中 result 是函数的回绕版本所返回的内容，而 overflowed 是一个布尔值，指示是否发生过溢出。

```rust
assert_eq!(5_u16.overflowing_shl(17), (10, true));
```

前缀`checked_`、`wrapping_`、`saturating_`、`overflowing_`可以跟着的运算名称如表:
|运算|名称后缀|例子|  
|-|-|-|
|加法|add|100_i8.checked_add(27) == Some(127)|
|减法|sub|10_u8.checked_sub(11) == None|
|乘法|mul|128_u8.saturating_mul(3) == 255|
|除法|div|64_u16.wrapping_div(8) == 8|
|求余|rem|(-32768_i16).wrapping_rem(-1) == 0|
|取负|neg|(-128_i8).checked_neg() == None|
|绝对值|abs|(-32768_i16).wrapping_abs() == None|
|求幂|pow|3_u8.checked_pow(4) == Some(81)|
|按位左移|shl |10_u32.wrapping_shl(34) == 40|
|按位右移|shr|40_u64.wrapping_shr(66)==10|
