## 表达式语言

Rust 是所谓的表达式语言，在 C 语言中， if 和 swtich 是语句，它们不生成值，也不能在表达式中间使用。而在 Rust 中，if 和 match 可以生成值。

```rust
pixels[r * bounds.0 + c] =
  match escapes(Complex { re: point.0, im: point.1 }, 255) {
    None => 0,
    Some(count) => 255 - count as u8
  }

// if 表达式可用于初始化变量
let status =
  if cpu.temperature <= MAX_TEMP {
    HttpStatus::Ok
  } else {
    HttpStatus::ServerError
  }
```

这也解释了为什么 Rust 没有 C 那样的三元运算符。在 C 中， 三元运算符是一个表达式级别的类似 if 语句的东西。这在 Rust 中是多余的。if 表达式足以处理这样的场景。C 中大多数控制流工具是语句。而在 Rust 中， 它们都是表达式。

## 优先级和结合性

优先级和结合性和其他语言的概念类似，这里不在赘述，但有几个表达式在需要注意
|名称|书写方式|
|-|-|
|右开区间范围|start .. stop|
|右闭区间范围|start ..= stop|
|闭包|&#124; x, y &#124; x + y|

## 块与分号

Rust 中的块和其他语言的块概念有点差别。在 Rust 中，一个块生成一个值，并且可以在任何需要值的地方使用。以下是块表达式的一些总结：

- 使用 let 生命变量时，分号总是必需的
- 带分号的表达式：调用方法，丢弃返回值。（即此语句的是 `()`）
- 无分号的表达式，通常是块中的最后一个表达式，如果不带分号，表示 `{...;  x }`的值为 `x`。

## 声明

```rust
let name: type = expr;
```

类型和初始化代码是可选的，分号则是必需的。与 Rust 中的所有标识符一样，变量名必须以字母或下划线开头。并且只能在第一个字符之后包含数字。Rust 中的字母是广义的。包括希腊字母、带重音的拉丁字符等符合 Unicode 标准的字符，也包括中文。但是不允许使用表情符号。

我们可能看到如下的生命方式：

```rust
for line in file.lines(){
  let line = line?;
  // ...
}
```

这个 let 声明会创建一个不同类型的、新的（第二个）变量。第一个 line 变量的类型是 Result<String, io::Error>。第二个 line 变量则是 String，第二个定义会在所处代码块的其余部分代替第一个定义。这叫做 遮蔽。在 Rust 程序中很常见，等价于下面的代码

```rust
for line_result in file.lines(){
  let line = line_result?;
  // ...
}
```

块（大括号里面的区域）还可以包含语法项声明。语法项是指可以在程序或模块中的任意地方出现的声明。比如`fn`、`struct`、`use`等。

当在一个块中声明一个函数时，这个行为和 javascript 不太一致。Rust 在块内声明函数 fn 时，它的作用域是整个块，但是 fn 无法访问恰好在同一作用域内的局部变量或者参数。

```rust
fn main() {
    let a = 1;
    let b = 3;
    fn add() {
      // 程序会报错，虽然可以定义函数，但是无法使用同一作用域的变量。
      return a + b;
    }
}
```

与之相对的是闭包，这个概念大概和 javascript 中的闭包类似。

## if 与 match

if 表达式的形式如下：

```rust
if condition1 {
  block1
} else if condition2 {
  block2
} else {
  block_n
}
```

每个 condition 都必须是 bool 类型的表达式，依照 Rust 的风格，不会隐式对其他类型转换，例如将 0 视为 false。 condition 周围并不需要圆括号。但大括号是必须的。else if 和 else 分支是可选的。没有的 else 块的表达时和具有空的 else 块完全相同。

match 表达式形式如下：

```rust
  match value {
    pattern1 => expr1,
    pattern2 => expr2,
    pattern3 => expr3,
    _ => default value,
  }
```

其中 `value`可以是任意的 Rust 表达式。与其他语言中的 switch 语句。但更为灵活。
下划线`_`的分支和其他 switch 的 default 分支一样。不过，必须将`_`分支排在最后。
而且，所有分支表达的返回值要求具有相同的类型。

> 编译器可以使用跳转表来优化这种 match，就像 C++ 中的 switch 语句一样。当 match 的每个分支都生成一个常量值时，也会应用与 C++ 类似的优化。在这种情况下，编译器会构建出这些值的数组，并将各个 match 项编译为数组访问。除了边界检查，编译后的代码中根本不存在任何分支。

`match`结构的多功能性源于每个分支 `=>` 左侧支持的多种模式。对模式的强大能力来说，这还是只是“冰山一角”。模式可以匹配一系列值，它可以结构元组、可以匹配结构体的各个字段、可以追踪引用、可以借用部分值。甚至可以说 Rust 的模式定义了自己的迷你语言。后面再详细介绍。

Rust 会从第一项开始依次根据每个模式检查给定的 value。 当模式能够匹配时，对应的 expr 会被求值，而当这个 match 表达式结束时，不会再检查别打模式。至少要有一个模式能够匹配。Rust 禁止执行未覆盖所有可能值（所以写一个`_`分支就行了）。

### if let

if 还有一种形式，即 if let 表达式。

```rust
if let pattern = expr {
  block1
} else {
  block2
}
```

给定的 _expr_ 要么匹配 _pattern_，这时会运行 _block1_；要么无法匹配，这时会运行 block2（else 分支也可以不写，这样当不匹配时默认什么都不会做）。有时这时从 Option 或 Result 中获取数据的好办法。

```rust
let a = if let 1 = 2 { 2 } else { 3 };
println!("{}", a);

// 上面的表达式和 match 是一样的
let a = match 2 {
  1 => 2,
  _ => 3
}
```

在上面这个例子中，如果 1 和 2 匹配，则整个表达式的值是 2，否则是 3。同样，if let 的表达式要求 if 语句块和 else 语句块的返回值类型相同。否则会报错，它是 match 表达的语法糖，通常只处理一个模式下使用，方便简洁。

### 循环

Rust 中有 4 种循环表达式：

```rust
while condition {
  // ...
}

while let pattern = expr {
  // ...
}

loop {
  // ...
}

for pattern in iterable {
  // ...
}
```

各种循环都是 Rust 中的表达式但 while 循环或 for 循环的值总是 `()`，因此它们的值通常没有什么用。

- while 循环的行为与 C 中的等效循环完全一样，只不过其 condition 必须是 bool 类型。
- while let 循环类似于 if let。在每次循环迭代开始时， expr 的值要么匹配给定的 pattern，这时会运行循环体；要么不匹配，这时会推出循环。
- 可以用 loop 来编写无限循环。它会永远重复执行循环体，直至遇上 break 或 return，或者遇到线程崩溃。

- for 循环会对可迭代(iterable)表达式求值，然后为结果迭代器中的每个值运行一次循环体。许多类型可以迭代，包括所有标准库集合，比如 Vec 和 HashMap。

为了与 Rust 的移动语义保持一致，把值用于 for 循环会消耗该值。

```rust
let strings: Vec<String> = error_messages();
for s in strings { // 在这里，每个String都会转移给 s
  println!("{}", s);
}

println!("{} error(s)", strings.len());// 这里会报错，因为strings的值已经被移动出去了
```

那我们可以使用引用来在 for 循环中使用，这样能避免移动

```rust
for s in &strings { // 这里的 s 类型是 &String

}

for s in &mut strings { // 这里的 s 类型是 &mut String

}
```

### 循环中的控制流

`break`表达式会退出所在循环。在 Rust 中，break 只能用在循环中，不能用在 match 表达式。

在 loop 的循环体中，可以在 break 后面跟一个表达式，该表达式的值会成为此 loop 的值。但有一个注意点，就是循环中的所有 break 返回的值必须是相同类型的值。

```rust
let answer = loop {
  if let Some(line) = next_line() {
    if line.starts_with("answer: ") {
      break line;
    }
  } else {
    break "answer: nothing";
  }
}
```

### return 表达式

return 表达式会退出当前函数，并向调用者返回一个值。
值得注意的是，不带值的 return 是 return() 的简写。

```rust
let output = File::created(filename)?;

// 等同于下面的表达式
let output = match File::created(filename) {
  Ok(f) => f,
  Err(err) => return Err(err)
}
```

### 为什么 Rust 中会有 loop

因为 Rust 的类型系统也会受控制流的影响，例如，if 表达式的分支限制所有的分支都必须具有相同的类型。但是，在可能以 break 或 return 表达式、无限 loop 或者调用 panic!() 或 std::process::exit() 等多种方式结束块上强制执行此规则是不现实的。而这些表达式没有正常类型。不能正常结束的表达式属于一个特殊的类型 `!`，并且它们不受“类型必须匹配”这条规则的约束。可以在 std::process::exit() 的函数签名中看到 `!`:

```rust
fn exit(code: i32) -> !
```

此处的`!`表示 exit() 永远不会返回，它是一个发散函数。比如你可以调用函数来启动一个服务器

```rust
fn serve_forever(socket: ServerSocket, handler: ServerHandler) => ! {
  socket.listen();
  loop {
    let s = socket.accpet();
    handler.handle(s);
  }
}
```

如果带有`!` 函数签名的函数中如果有正常的返回值，反而是一个错误了。
