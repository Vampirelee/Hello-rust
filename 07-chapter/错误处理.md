## 错误处理

这里先介绍 Rust 中的两类错误处理：`panic` 和 `Result`。

普通错误使用 Result 类型来处理。Result 通常用以表示由程序外部的事物引发的错误，比如错误的输入、网络中断或权限问题。这些问题并不是意料之中的，在没有任何 bug 的程序中也可能会不时出现。

panic 针对的是另一种错误，即那种永远不应该发生的错误。

## pinic

当程序遇到下列问题的时候，就可以断定程序自身存在 bug，故而会引发 panic

- 数组越界访问
- 整数除以 0
- 在恰好为 `Err` 的 `Result` 上调用 `.expect()`;
- 断言失败

panic!() 是一种宏，用于处理程序中出现错误的情况。当你的代码检测到出现错误并需要立即触发 panic 时，就可以使用这个宏。`panic!()`可以接受类似于 `println!()`的可选参数表，用于构建错误信息。

### 展开调用栈

当 Rust 遇到 panic 时，那么当前发生异常的函数使用任何的临时值、局部变量或参数都将按照与创建它们时相反的顺序被丢弃。丢弃一个值仅仅意味着随后会进行清理：程序正在使用的任何字符串或向量都将被释放，所有打开的文件都将被关闭，等等。

### 中止

调用栈展开是默认的 panic 处理行为，但在两种情况下 Rust 不会试图展开调用栈。
如果 Rust 在试图清理第一个 panic 时， `.drop()`方法触发了第二个 panic，那么这个 panic 就是致命的。Rust 会停止展开调用栈并中止整个进程。

## Result

Rust 总没有异常。相反，函数执行失败时会有像下面这样的返回类型：

```rust
fn get_weather(location: LatLng) -> Result<WeatherReport, io::Error>
```

Result 类型会指示出可能的失败。当我们调用 get_weather() 函数时，它要么返回一个成功结果`Ok(weather)`，其中的 weather 是一个新的 WeatherReport 值；要么返回一个错误结果 Err(error_value)，其中的 error_value 是一个 io::Error，用来解释出了什么问题。

### 捕获错误

来看一个例子吧

```rust
match get_weather(hometown) {
  Ok(report) => {
    display_weather(hometown, &report);
  }
  Err(err) => {
    println!("error querying the weather: {}", err);
    schedule_weather_retry();
  }
}
```

这相当于其他语言中的 try/catch。如果想直接处理错误而不是将错误传给调用者，就可以使用这种方式。

match 有点儿冗长，因此 `Result<T, E>`针对一些常见的特定场景提供了多个有用的方法，每个方法在其实现中都有一个 match 表达式。

- `result.is_ok()` 已成功， `result.is_err()` 出错。返回一个 bool，告知此结果是成功了还是出错了。

- `result.ok()`，以 `Option<T>`类型返回成功值（如果有的话）。如果 result 是成功的结果，就返回 Some(success_value)；否则，返回 None，并丢弃错误值。

- `result.err()`，错误值，以 `Option<E>` 类型返回错误值。

- `result.unwrap_or(fallback)` 如果 result 为成功结果，就返回成功值；否则，返回 fallback，丢弃错误值。

- `result.unwrap_or_else(fallback_fn)` 这个方法和 `unwrap_or`类似，但不会直接传入回退值，而是传入一个函数或闭包。它针对的是大概率不会用到回退值且计算回退值会造成浪费的情况。只有在得到错误结果时才会调用 `fallback_fn`。
- `unwrap()` 解包，如果 result 是成功的结果，那么此方法同样会返回成功值。但是 result 是错误结果，则会引发 panic。
- `expect(message)` 与 `.unwrap()`相同，但此方法允许你提供一条消息，在发生 panic 时会打印该消息。且会引发 panic 。
- `result.as_ref()` 转共享引用，将 `Result<T, E>`转换为 `Result<&T, &E>`;
- `result.as_mut()` 转可变引用，将 `Result<T, E>`转换为 `Result<&mut T, &mut E>`;

最后转引用这两个方法之所以有用，是因为前面列出的所有其他方法，除了`.is_ok()` 和 `.is_err()`，都在消耗 result。也就是说，它们按值接受 self 参数。有时在不破坏 result 的情况下访问 result 中的数据是非常方便的。例如 `result.as_rer().ok()`
