# 迭代器

迭代器是一个值，它可以生成一系列值，通常用来执行循环操作。Rust 的标准库不仅提供了用于遍历向量、字符串、哈希表和其他集合的迭代器，还提供了“从输入流中产生文本行”“从网络服务器中产生新的入站连接”“从通信通道中其他线程接收的值”等迭代器。当然，你也可以出于自己的目的实现迭代器。Rust 的 for 循环为使用迭代器提供了一种自然的语法，但迭代器本身也提供了一组丰富的方法，比如映射(map)、过滤(filter)、连接(join)、收集 (collect)等

Rust 的各种迭代器灵活、富有表现力而且高效。考虑以下函数，它会 返回前 n 个正整数之和

```rust
fn triangle(n: i32) -> i32 {
  let mut sum = 0;
  for i in 1..=n {
    sum += i;
  }
  sum
}
```

表达式 1..=n 是一个 `RangeInclusive<i32>` 型的值。而 `RangeInclusive<i32>` 是一个迭代器，可以生成其起始值到结束值(包括两者)之间的整数，因此你可以将它用作 for 循环的操作数来对从 1 到 n 的值求和。

迭代器还有一个 fold 方法，可以实现完全一样的效果

```rust
fn triangle(n: i32) -> i32 {
  (i..=n).fold(0, |sum, item| sum + item)
}
```

开始运行时以 0 作为总和，fold 会获取 1..=n 生成的每个值，并以总和(sum)跟当前值(item)为参数调用闭包 |sum, item| sum + item。闭包的返回值会作为新的总和。它返回的最后一个值就是 fold 自身要返回的值, 类似于 javascript 数组中的 reduce 方法

## Iterator 特型与 IntoIterator 特型

迭代器是实现了 std::iter::Iterator 特型的任意值

```rust
trait Iterator {
  type Item;
  fn next(&mut self) -> Option<Self::Item>
}
```

Item 是迭代器所生成的值的类型。next 方法要么返回 Some(v) (其中 v 是迭代器的下一个值)，要么返回 None(作为序列结束的 标志)。这里我们省略了 Iterator 的许多默认方法

只要可以用某种自然的方式来迭代某种类型，该类型就可以实现 `std::iter::IntoIterator`，其 into_iter 方法会接受一个值 并返回一个迭代器

```rust
trait IntoIterator where Self::IntoIter: Iterator<Item=Self::Item> {
  type Item;
  type IntoIter: Iterator;
  fn into_iter(self) -> Self::IntoIter;
}
```

IntoIter 是迭代器本身的类型，而 Item 是它生成的值的类型。 任何实现了 IntoIterator 的类型都称为可迭代者，因为你可以随意迭代它。

Rust 的 for 循环会将所有这些部分很好地结合在一起。要遍历向量的元素，你可以这样写

```rust
let v = vec!["antimony", "arsenic", "aluminum", "selenium"];
for element in &v {
  println!("{}", element);
}
```

在幕后, 每个 for 循环都只是调用 IntoIterator 和 Iterator 中某些方法的简写形式:

```rust
let mut iterator = (&v).into_iter();
while let Some(element) = iterator.next() {
    println!("{}", element);
}
```

for 循环会使用 `IntoIterator::into_iter` 将其操作数 `&v` 转换为迭代器，然后重复调用 `Iterator::next`。每次返回 `Some(element)` 时，for 循环都会执行其循环体，如果返回 None，则循环结束

- 迭代器是实现了 `Iterator` 的任意类型
- 可迭代者是任何实现了 `IntoIterator` 的类型:你可以通过调用它的 `into_iter` 方法来获得一个迭代器。在上面的例子中，向量引用 `&v` 就是可迭代者
- 迭代器能生成着
- 迭代器生成的值是条目, 也就是例子中的 "antimony"、"arsenic" 等等
- 接收迭代器所生成条目的代码是消费者。for 循环体就是消费者

虽然 for 循环总会在其操作数上调用 into_iter，但你也可以直接把迭代器传给 for 循环

```rust
let v = vec!["antimony", "arsenic", "aluminum", "selenium"];
let iterator = (&v).into_iter();
for element in iterator {
    println!("{}", element);
}
```

如果在返回 None 后再次调用迭代器的 next 方法，则 Iterator 特型没有规定它应该做什么。大多数迭代器只会再次返回 None

## 创建迭代器

### iter 方法与 iter_mut 方法

大多数集合类型提供了 iter(迭代器)方法和 iter_mut(可变迭代器)方法，它们会返回该类型的自然迭代器，为每个条目生成共享引用或可变引用。像 `&[T]` 和 `&mut [T]` 这样的数组切片也有 iter 方法和 iter_mut 方法

```rust
let v = vec![4, 20, 12, 8, 6];
let mut iterator = v.iter();
assert_eq!(iterator.next(), Some(&4));
assert_eq!(iterator.next(), Some(&20));
assert_eq!(iterator.next(), Some(&12));
assert_eq!(iterator.next(), Some(&8));
assert_eq!(iterator.next(), Some(&6));
assert_eq!(iterator.next(), None);
```

### IntoIterator 的实现

如果一个类型实现了 IntoIterator，你也可以自行调用它的 into_iter 方法，就像 for 循环一样

```rust
// 大家通常会使用HashSet，但它的迭代顺序是不确定的，
// 因此在这个示例中用了BTreeSet，它的演示效果更好些
use std::collections::BTreeSet;
let mut favorites = BTreeSet::new();
favorites.insert("Lucy in the Sky With Diamonds".to_string());
favorites.insert("Liebesträume No. 3".to_string());
let mut it = favorites.into_iter();
assert_eq!(it.next(), Some("Liebesträume No. 3".to_string()));
assert_eq!(it.next(), Some("Lucy in the Sky With Diamonds".to_string()));
assert_eq!(it.next(), None);
```

大多数集合实际上提供了 IntoIterator 的几种实现，用于共享引用(&T)、可变引用(&mut T)和移动(T)。

- 给定一个集合的共享引用, into_iter 会返回一个迭代器, 该迭代器生成对其条目的共享引用. 例如, (&favorites).into_iter() 会返回一个 Item 类型为 &String 的迭代器
- 给定对集合的可变引用, into_iter 会返回一个迭代器, 该迭代器会生成对其条目的可变引用. 如果 vector 是某个 `Vec<String>`, 则调用 (&mut vector).into_iter() 会返回一个 Item 类型为 &mut String 的迭代器
- 当按值传递集合时，into_iter 会返回一个迭代器，该迭代器会获取集合的所有权并按值返回这些条目，这些条目的所有权会从集合转移给消费者，原始集合在此过程中已被消耗掉了, 例如， favorites.into_iter() 调用返回了一个迭代器，该迭代器会按值生成每个字符串，消费者会获得每个字符串的所有权。当迭代器被丢弃时，BTreeSet 中剩余的所有 元素都将被丢弃，并且该集合的空壳也将被丢弃

由于 for 循环会将 IntoIterator::into_iter 作为它的操作对象，因此这 3 种实现创建了以下惯用法，用于迭代对集合的共享引用或可变引用，或者消耗该集合并获取其元素的所有权

```rust
// 共享引用
for element in &collection {
  // ...
}
// 可变引用
for element in &mut collection {
  // ...
}
// 所有权转移
for element in collection {
  // ...
}
```

并非每种类型都提供了这 3 种实现，比如，HashSet、BTreeSet 和 BinaryHeap 不会在可变引用上实现 IntoIterator，因为修改它们的元素可能会违反类型自身的不变性规则——修改后的值很可能有不同的哈希值，或者相对于其邻居的顺序改变了，所以修改它会让该类型处于错误状态。

另一部分类型确实支持修改，但只支持修改一部分，比如，HashMap 和 BTreeMap 会生成对其条目值的可变引用，但只能提供对其键的共享引用，原因与上面给出的相似。

对于共享引用和可变引用，前两个 IntoIterator 变体等效于在引用目标上调用 iter 或 iter_mut。为什么 Rust 要同时提供 into_iter 和 iter 这两 种方式呢?

IntoIterator 是确保 for 循环工作的关键，显而易见它是必要的。但当我们不用 for 循环时，写 favorites.iter() 会比 (&favorites).into_iter() 更清晰。我们会频繁通过共享引用进行迭代，因此 iter 和 iter_mut 仍然具有很高的工效学价值。

> into_iter() 用于消耗并转移集合的所有权以获得迭代器，而 iter() 返回一个不消耗集合的不可变引用的迭代器。即 favorites.iter() 和 (&favorites).into_iter() 效果是一样的

IntoIterator 在泛型代码中也很有用, 你可以使用像 `T: IntoIterator` 这样的限界来将类型变量 T 限制为可以迭代的类型，还可以编写 `T: IntoIterator<Item=U>` 来进一步要求迭代时生成具有特定类型 U 的条目。

### from_fn 与 successors

要生成一系列值，有一种简单而通用的方法，那就是提供一个能返回这些值的闭包。

给定返回 `Option<T>` 的函数，`std::iter::from_fn`(来自 fn)就会返回一个迭代器，该迭代器会调用 fn 来生成条目。

```rust
use rand::random;
use std::iter::from_fn;

// 产生1000条端点均匀分布在区间[0, 1]上的随机线段的长度(这并不是
// `rand_distr` crate中能找到的分布类型，但你可以轻易实现一个)
let lengths: Vec<f64> = from_fn(|| Some((random::<f64>() - random::<f64>())))
    .take(1000)
    .collect();
```

它会调用 from_fn 来让迭代器产生随机数。由于迭代器总是返回 Some，因此序列永不结束，但我们调用 take(1000) 时会将其限制为前 1000 个元素。然后 collect 会从这 1000 次迭代中构建出向量。这是构造已初始化向量的有效方式.

如果每个条目都依赖于其前一个条目，那么 std::iter::successors 函数很实用。只需要提供一个初始条目和一个函数，且该函数能接受一个条目并返回下一个条目的 Option。如果返回 None，则迭代结束

```rust
fn escape_time(c: Complex<f64>, limit: usize) -> Option<usize> {
    let zero = Complex::<f64>::default();

    successors(Some(zero), |&z| Some(z * z + c))
        .take(limit)
        .enumerate()
        .find(|(_i, z)| z.norm_sqr() > 4.0)
        .map(|(i, _z)| i)
}
```

从零开始，successors(后继者)调用会通过反复对最后一个点求平方再加上参数 c 来生成复平面上的一系列点。在绘制曼德博集时，我们想看看这个序列是永远在原点附近打转还是“飞向”无穷 远。调用 take(limit) 确定了我们追踪序列的次数限制，然后 enumerate 对每个点进行编号，将每个点 z 变成元组 (i, z)。 我们使用 find 来寻找距离原点足够远的第一个点以判断是否逃逸。 find 方法会返回一个 Option:如果这样的点存在就返回 Some((i, z))，否则返回 None。调用 Option::map 会将 Some((i, z)) 变成 Some(i)，但不会改变 None，因为这正是我们想要的返回值。

from_fn 和 successors 都接受 FnMut 闭包，因此你的闭包可以捕获和修改周边作用域中的变量。例如，下面的 fibonacci 函数就用 move 闭包来捕获一个变量并将其用作自己的运行状态

```rust
fn fibonacci() -> impl Iterator<Item = usize> {
    let mut state = (0, 1);
    std::iter::from_fn(move || {
        state = (state.1, state.0 + state.1);
        Some(state.0)
    })
}
```

需要注意的是，from_fn 方法和 successors 方法非常灵活，你几乎可以将任何对迭代器的使用改写成对其中之一的调用，通过传递复杂的闭包来得到你想要的行为。但这样做浪费了迭代器提供的机会，即使用常见模式的标准名称来更清晰地表达计算中的数据流。

> 简而言之, 这两个方法应该作为我们最后的选项, 而不是一上来就使用

### drain 方法
