# 集合

Rust 标准库包含多个 ，这些集合是泛型类型，用于在内存中存储各种数据。

移动和借用无处不在。Rust 使用移动来避免对值做深拷贝。这就是 `Vec<T>::push(item)` 方法会按值而非按引用来获取参数的原因。这样值就会移动到向量中。 将 String 压入 `Vec<String>` 中会很快，因为 Rust 不必复制字符串的字符数据，并且字符串的所有权始终是明晰的。

其次，Rust 没有失效型错误，也就是当程序仍持有指向集合内部数据的指针时，集合被重新调整大小或发生其他变化而导致的那种悬空指针错误。

最后，Rust 没有 null，因此在其他语言使用 null 的地方 Rust 会使用 Option。

## 概述

下面展示了 Rust 的 8 个标准集合，它们都是泛型类型。
|集合|描述|详细|
|-|-|-|
|Vec<T>|可增长数组|可增长的、分配在堆上的 T 类型值数组|
|VecDeque<T>|可增长数组(可增长的环形缓冲区)|与 Vec<T> 类似，但更适合用作先入先出队列|
|LinkedList<T>|双向链表|
|BinaryHeap<T> where T: Ord|二叉堆|优先级队列。BinaryHeap 中的值是精心组织过的，因始终可以高效地查找和移除其最大值|
|HashMap<K, V> where K: Eq + Hash|键值哈希表|由键-值对构成的表。通过键查找值很快。其条目会以任意顺序存储。|
|BTreeMap<K, V> where K: Ord|有序键值表|与 `HashMap<K, V>` 类似，但它会根据键来对条目进行排序。 `BTreeMap<String, i32>` 会以 String 的比较顺序来存储其条目。除非需要让条目保持排序状态，否则用 HashMap 更快一些|
|HashSet<T> where T: Eq + Hash|无序的、 基于哈希的集合|由 T 类型的值组成的 Set。它既能很快地添加值和移除值，也能很快地查询给定值是否在此 Set 中|
|BTreeSet<T> where T: Ord|有序集|与 HashSet<T> 类似，但它会让元素按值排序。同样，除非需要让数据保持排序状态，否则用 HashSet 更快一些。|

`Vec<T>`、`HashMap<K, V>` 和 `HashSet<T>` 是最常用的集合类型，其余的都各自有其基本应用场景。

## `Vec<T>`

创建向量的最简单方法是使用 vec! 宏:

```rust
let mut numbers: Vec<i32> = vec![];

let words = vec!["step", "on", "no", "pets"];
let mut buffer = vec![0u8; 1024]; // 1024个内容为0的字节
```

向量具有 3 个字段:长度、容量和指向用于存储元素的堆分配内存的指针。下图展示了前面的向量在内存中的布局方式。空向量 numbers 最初的容量为 0。直到添加第一个元素之前，不会为其分配堆内存。

![](./images/1.png)

与所有集合一样，Vec 也实现了 `std::iter::FromIterator`，所以可以使用迭代器的 `.collect()` 方法从任意迭代器创建向量

```rust
let my_vec = my_set.into_iter().collect::<Vec<String>>();
```

### 访问元素

通过索引来获取数组、切片或向量的元素非常简单

```rust
let first_line = &lines[0];

let fifth_number = numbers[4];
let second_line = lines[1].clone();

let my_ref = &buffer[4..12];

let my_copy = buffer[4..12].to_vec();
```

如果索引超出了范围，则所有这些形式都会引发 panic。

Rust 对数值类型很挑剔，对向量也不例外。向量的长度和索引都是 usize 类型。试图用 u32、u64 或 isize 作为向量索引会导致出错。可以根据需要使用 n as usize 来转换

下面这些方法可以轻松访问向量或切片的特定元素(请注意，所有的切片方法也都适用于数组和向量)。

- slice.first() 返回第一个元素的引用

```rust
slice.first(); //
```

返回类型为 Option<&T>，所以如果 slice 为空则返回值为 None，如果不为空则返回 `Some(&slice[0])`

```rust
if let Some(item) = v.first() {
    println!("We got one! {}", item);
}
```

- slice.last() 返回最后一个元素的引用
- slice.get(index) 获取位置为 index 的元素的索引, 如果其存在，就返回 `slice[index]` 引用的 Some 值。如果 slice 的元素少于 `index+1` 个，则返回 None
- slice.first_mut() 返回第一个元素的可变索引
- slice.last_mut() 返回最后一个元素的可变索引
- slice.get_mut(index) 获取位置为 index 的可变索引

```rust
let mut slice = [0, 1, 2, 3];
{
    let last = slice.last_mut().unwrap();
    assert_eq!(*last, 3);
    *last = 100;
}
assert_eq!(slice, [0, 1, 2, 100]);
```

按值返回 T 就意味着移动它，所以一些需要就地访问元素的方法通常会按引用返回这些元素。

- to_vec() 方法是一个例外，它会复制这些元素。

克隆整个切片，返回一个新向量, 此方法只能用在元素可以克隆的情况下，也就是需满足 where T: Clone 限界

```rust
let v = [1, 2, 3, 4, 5, 6, 7, 8, 9];
assert_eq!(v.to_vec(),
           vec![1, 2, 3, 4, 5, 6, 7, 8, 9]);
assert_eq!(v[0..6].to_vec(),
           vec![1, 2, 3, 4, 5, 6]);
```

### 迭代

向量、数组和切片是可迭代的，要么按值迭代 ，要么按引用迭代

> 其实除非元素是 Copy 类型，否则切片并不能按值迭代

- 遍历 `Vec<T>` 或数组 `[T; n]` 会生成 T 类型的条目。 这些元素会逐个从向量或数组中移动出来并被消耗掉
- 遍历 `&[T; N]`、`&[T]` 或 `&Vec<T>` 类型的值（对数组、切片或向量的引用）会生成` &T` 类型的条目，即对单个元素的引用，这些元素不会移动出来。
- 遍历 `&mut [T; N]`、`&mut [T]` 或 `&mut Vec<T>` 类型的值会生成 `&mut T`类型的条目

数组、切片和向量也有 `.iter()` 方法和 `.iter_mut()` 方法，以用于创建一个会生成对其元素的引用的迭代器
