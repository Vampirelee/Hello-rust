# 集合

Rust 标准库包含多个 ，这些集合是泛型类型，用于在内存中存储各种数据。

移动和借用无处不在。Rust 使用移动来避免对值做深拷贝。这就是 `Vec<T>::push(item)` 方法会按值而非按引用来获取参数的原因。这样值就会移动到向量中。 将 String 压入 `Vec<String>` 中会很快，因为 Rust 不必复制字符串的字符数据，并且字符串的所有权始终是明晰的。

其次，Rust 没有失效型错误，也就是当程序仍持有指向集合内部数据的指针时，集合被重新调整大小或发生其他变化而导致的那种悬空指针错误。

最后，Rust 没有 null，因此在其他语言使用 null 的地方 Rust 会使用 Option。

## 概述

下面展示了 Rust 的 8 个标准集合，它们都是泛型类型。
|集合|描述|详细|
|-|-|-|
|Vec<T>|可增长数组|可增长的、分配在堆上的 T 类型值数组|
|VecDeque<T>|可增长数组(可增长的环形缓冲区)|与 Vec<T> 类似，但更适合用作先入先出队列|
|LinkedList<T>|双向链表|
|BinaryHeap<T> where T: Ord|二叉堆|优先级队列。BinaryHeap 中的值是精心组织过的，因始终可以高效地查找和移除其最大值|
|HashMap<K, V> where K: Eq + Hash|键值哈希表|由键-值对构成的表。通过键查找值很快。其条目会以任意顺序存储。|
|BTreeMap<K, V> where K: Ord|有序键值表|与 `HashMap<K, V>` 类似，但它会根据键来对条目进行排序。 `BTreeMap<String, i32>` 会以 String 的比较顺序来存储其条目。除非需要让条目保持排序状态，否则用 HashMap 更快一些|
|HashSet<T> where T: Eq + Hash|无序的、 基于哈希的集合|由 T 类型的值组成的 Set。它既能很快地添加值和移除值，也能很快地查询给定值是否在此 Set 中|
|BTreeSet<T> where T: Ord|有序集|与 HashSet<T> 类似，但它会让元素按值排序。同样，除非需要让数据保持排序状态，否则用 HashSet 更快一些。|

`Vec<T>`、`HashMap<K, V>` 和 `HashSet<T>` 是最常用的集合类型，其余的都各自有其基本应用场景。
