# 引用

Rust 一共有两种指针类型

- 拥有型指针。当拥有者被丢弃时，它的引用目标也随之丢弃。
- 非拥有型指针。这种指针对引用目标的生命周期毫无影响。

借用的概念：创建对某个值的引用称为借用。

- 借用的生命周期绝不能超出其引用目标的生命周期。

## 对值的引用

引用能让你在不影响其所有权的情况下访问值。引用分为两种：

- 共享引用允许你读取但不能修改其引用目标。但你可以根据需要同时拥有任意数量的对特征值的共享引用。值得注意的是：共享引用是`Copy`类型。
- 可变引用允许你读取和修改值，但是，一旦一个值拥有了可变引用，就无法再对该值创建其他任何种类的引用了。且这个值暂时失去对数据的控制，它也不能对堆中的数据进行读和写操作。可变引用不是`Copy`类型。

可以将共享引用和可变引用之间的区别视为在编译期强制执行“多重读取”或“单一写入”规则的一种手段。事实上，这条规则不仅适用于引用，也适用于所引用值的拥有者。只要存在对一个值的共享引用，即使是它的拥有者也不能修改它，该值会被锁定。当 show 正在使用 table 时，没有人可以修改它。类似地，如果有某个值的可变引用，那么它就会独占对该值的访问权，在可变引用消失之前，即使拥有者也根本无法使用该值。事实证明，让共享和修改保持完全分离对于内存安全至关重要.

以下是共享引用的一个例子：

```rust
use std::collections::HashMap;
type Table = HashMap<String, Vec<String>>;
fn main() {
    let mut table = Table::new();
    table.insert(
        "Gesualdo".to_string(),
        vec![
            "many madrigals".to_string(),
            "Tenebrae Responsoria".to_string(),
        ],
    );
    table.insert(
        "Caravaggio".to_string(),
        vec![
            "The Musicians".to_string(),
            "The Calling of St. Matthew".to_string(),
        ],
    );
    table.insert(
        "Cellini".to_string(),
        vec![
            "Perseus with the head of
Medusa"
                .to_string(),
            "a salt cellar".to_string(),
        ],
    );
    show(&table)
}
fn show(table: &Table) {
    for (artist, works) in table {
        println!("works by {}:", artist);
        for work in works {
            println!("  {}", work);
        }
    }
}
```

如果我们要修改 `table`变量的数据，只需像函数传递 `&mut Table`这种可变引用。加入我们直接传入 `table`数据的话，那么一旦对其进行`for`操作后，`table`会在一次次的循环中丢弃所有的数据。这并不是我们所想要的。

### 使用引用

在 Rust 中，引用是通过 `&`运算符显式创建的。同时要使用`*`运算符显式的解引用。因为在 Rust 程序中，引用是非常常用的操作，所以在遇到`.`运算符时，我们不必要使用`*`来对其左操作数隐式解引用。编译器它自己帮我们做了。

```rust
let num = 10;
let a = &num;
assert_eq!(*a, num);


// 遇到 . 运算符时，编译器会进行隐解引用
let mut str = "qweqwe".to_string();
let a = &mut str;
a.push('1'); // 等价于 (*a).push('1');
println!("{}", a);
```

同时， `.`也会在合适的场景进行隐式进行可变引用。在我们之前的例子中，在使用数组切片上的方法时，实质上也是隐式使用可变引用的。

```rust
  let mut arr = vec![3, 2, 1];
  arr.sort(); // 等价于 (&mut arr).sort();

  // 打印每个元素的值，注意这里对 arr 需要使用共享引用，否则 for 循环之后将丢弃 arr 的值。
  for el in &arr {
      println!("{}", el);
  }
```

### 对引用变量赋值

在 C++ 中，一旦使用引用，那么它将不会改变，保持一直对该值的使用。而在 Rust 中，把引用赋值给某个引用变量，会让该变量指向新的地方。

```rust
let x = 10;
let y = 10;
let mut r = &x;

if something {
    // 这里变量 r 更改了指向
    r = &y;
}
assert!(*r == 10 || *r == 20);
```

上面这个例子的内存示意图：
![](./images/1.png)

### 对引用进行引用

Rust 允许对引用进行引用：

```rust
let point = Point { x: 1000, y: 729 };
let r = &point;
let rr = &r;
let rrr = &rr;

assert_eq!(rrr.x, rrr.y);
```

其内存示意图为：

![](./images/2.png)

Rust 编译器是足够智能的，多重引用遇到`.`运算符一样可以解引用，无论它层级有多深。

### 比较引用

和`.`运算符一样，比较运算符也能解除任意数量的引用

```rust
let x = 10;
let y = 10;

let rx = &x;
let ry = &y;

let rrx = &rx;
let rry = &ry;

// 这里rx和ry会解除引用
assert!(rx == ry);
// 这里rrx和rry会解除引用
assert!(rrx == rry);

// 如果你需要对比地址空间是否一致，可以使用下面的方法
assert!(!std::ptr::eq(rx, ry));

// 值得注意的是，比较运算符必须具有完全相同的类型
assert!(rx == rry); // 这里将报错，因为 rx 和 rry 的类型不一致。
```

### 引用永不为空

Rust 的引用永远都不会为空。如果非要表示某个值可能为空，在 Rust 中常见的做法是使用类型 `Option<&T>`，在机器吗级别，Rust 会将 `None`表示为空指针，将`Some(r)`表示为非零地址（`r` 的类型是 `&T`）。

Rust 允许借用任意种类的表达式结果值的引用：

```rust
// Rust 这里可以看穿一层引用
println!("{}", &1 + &1); // 将打印 2
```

### 对切片和特型对象的引用

Rust 还有一个概念，就是胖指针。胖指针是指某个值地址的双字值。比如对切片的引用就是一个胖指针，携带着此切片的起始地址及其长度。

Rust 的另一种胖指针是特型对象，即对实现了指定特型的值的引用。特型对象会携带一个值的地址和指向适用于该值的特型实现的指针，以便调用特型的方法。

除了会携带这些额外的数据，切片和特型对象引用的行为与其他引用是一样的。它们并不拥有自己的引用目标、它们的生命周期也不允许超出它们的引用目标，它们可能是可变的或共享的。

## 引用安全

### 借用局部变量

你不能借用对局部变量的引用并将其移出变量的作用域，下面的这个例子中，当执行到 `}`后，变量`x`变丢弃了，此时就不能在使用`*r`对其进行解引用了。

```rust
let r;
{
    let x = 1;
    r = &x;
}
// - `x` dropped here while still borrowed
assert_eq!(*r, 1);
```

> 对于变量和借用它的引用来说，引用的生命周期（作用域）不能超出变量的生命周期（作用域）。这个规则对于借用大型数据结构中的某些部分也使用，比如借用向量中的某个元素


### 将引用作为函数参数