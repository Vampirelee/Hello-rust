# 使用特性

特型是一种语言特性,我们可以说某类型支持或不支持某个特型. 大多数情况下, 特型代表着一种能力, 即一个类型能做什么.

比如:

- 实现了 std::io::Write 的值能写出一些字节。
- 实现了 std::iter::Iterator 的值能生成一系列值。
- 实现了 std::clone::Clone 的值能在内存中克隆自身。
- 实现了 std::fmt::Debug 的值能用带有 {:?} 格式说明符的 println!() 打印出来。

上述这 4 个特型都是 Rust 标准库的一部分，许多标准类型实现了它们。

- std::fs::File 实现了 Write 特型, 它能将一些字节写入本地文件. std::net::TcpStream 能写入网络连接. `Vec<u8>` 也实现了 Write, 对字节向量的每次 .write() 调用都会将一些数据追加到向量末尾.
- `Range<i32>`(表达式 0..10 的类型) 实现了 Iterator 特型,一些与切片、哈希表等关联的迭代器类型同样实现了 Iterator 特型.
- 大多数标准库类型实现了 Clone. 没实现 Clone 的主要是一些像 TcpStream 这样的类型, 因为它们代表的不仅仅是内存中的数据.
- 同样, 大多数标准库类型支持 Debug

关于特型方法有一条值得注意的规则, 特型本身必须在作用域内. 否则, 它的所有方法都是不可见的.

```rust
let mut buf: Vec<u8> = vec![];
buf.write_all(b"hello")?; // 错误: 没有名为 write_all 的方法
```

在这种情况下, 编译器会打印出一条友好的错误消息, 建议添加 use std::io::Write; 就可以解决问题:

```rust
use std::io::Write;

let mut buf:: Vec<u8> = vec![];
buf.write_all(b"hello")?;   // 正确
```

之所以 Rust 会有这条规则, 是因为你可以使用特型为任意类型添加新方法 —— 甚至是像 u32 和 str 这样的标准库类型. 而第三方 crate 也可以这样做. 但是这可能导致命名冲突. 但是由于 Rust 会要求你导入自己想用的特型, 因此 crate 可以放心地利用这种超能力. 只有导入两个特型, 才会发生冲突, 将具有相同名称的方法添加到同一个类型中. 这在实践中非常罕见.

> Clone 和 Iterator 的各个方法在没有任何特殊导入的情况下就能工作, 因为默认情况下它们始终在作用域中, 它们是标准库预导入的一部分, Rust 会把这些名称自动导入每个模块中. 事实上, 预导入主要就是一些精心挑选的特型.

## 特型对象

在 Rust 中使用特型编写多态代码有两种方法: 特型对象和泛型.

对特型类型的引用叫做**特型对象**. 与任何其他引用一样, 特型对象指向某个值, 它具有生命周期, 并且可以是可变或共享的.

特型对象的与众不同之处在于, Rust 通常无法在编译期间知道引用目标的类型. 因此, 特型对象要包含一些关于引用目标类型的额外信息. 这仅供 Rust 自己在幕后使用: 当你调用 writer.writer(data) 时, Rust 需要使用类型信息来根据 `*writer` 的具体类型动态调用正确的 write 方法. 不能直接查询这些类型信息, Rust 也不支持从特型对象 &mut dyn Write 向下转型会像 `Vec<u8>` 这样的具体类型

### 特型对象的内存布局

在内存中, 特型对象是一个胖指针, 由指向值的指针和指向表示该值类型的虚表的指针组成. 因此, 每个特型对象会占用两个机器字. 如图所示:

![](./images/1.png)

Rust 在需要时会自动将普通引用转为特型对象.

```rust
let mut local_file = File::create("hello.txt")?;
say_hello(&mut local_file)?;
```

`&mut local_file`的类型是 `&mut File`, `say_hello`的参数类型是 `&mut dyn Write`. 由于 File 也是一种写入器, 因此 Rust 允许这样的操作, 它会自动将普通引用转换为特型对象.

同样, Rust 会愉快地将 `Box<File>`转换为 `Box<dyn Write>`, 这是一个拥有在堆中分配的写入器的值

```rust
let w: Box<dyn Write> = Box::new(local_file);
```


