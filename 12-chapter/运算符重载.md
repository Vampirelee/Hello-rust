# 运算符重载

Rust 运算符重载的特型汇总表
|类别|特型|运算符|
|-|-|-|
|一元运算符|std::ops::Neg<br>std::ops::Not|-x<br>!x|
|算术运算符|std::ops::Add<br>std::ops::Sub<br>std::ops::Mul<br>std::ops::Div<br>std::ops::Rem|x + y<br>x - y<br>x \* y<br>x / y<br>x % y|
|按位运算符|std::ops::BitAnd<br>std::ops::BitOr<br>std::ops::BitXor<br>std::ops::Shl<br>std::ops::Shr|x & y<br>x \| y<br>x ^ y<br>x << y<br>x >> y|
|复合赋值算术运算符|std::ops::AddAssign<br>std::ops::SubAssign<br>std::ops::MulAssign<br>std::ops::DivAssign<br>std::ops::RemAssign|x += y<br>x -= y<br>x \*= y<br>x /= y<br>x &= y|
|复合赋值按位运算符|std::ops::BitAndAssign<br>std::ops::BitOrAssign<br>std::ops::BitXorAssign<br>std::ops::ShlAssign<br>std::ops::ShrAssign|x &= y<br>x \|= y<br>x ^= y<br>x <<= y<br>x >>= y|
|比较|std::cmp::PartialEq<br>std::cmp::PartialOrd|x == y<br>x != y<br>x < y<br>x <= y<br>x > y<br>x >= y|
|索引|std::ops::Index<br>std::ops::IndexMut|x[y]<br>&x[y]<br>x[y]=z<br>&mut x[y]|

## 算术运算符与按位运算符

在 Rust 中, 表达式 a + b 实际上是 a.add(b) 的简写形式, 也就是对标准库中 std::ops::Add 特型的 add 方法的调用.

如果试图写出 z.add(c)，就要将 Add 特型引入作用域，以便它的方法在此可见。做完这些，就可以将所有算术运算视为函数调用了

> 表达式 `<i32 as Add>::add` 就是 i32 的 + 运算符, 其结果是函数的返回值.

```rust
use std::ops::Add;

assert_eq!(4.125f32.add(5.75), 9.875);
assert_eq!(10.add(20), 10 + 20);
```

std::ops::Add 的定义如下:

```rust
trait Add<Rhs = Self> {
  type Output;
  fn add(self, rhs:Rhs) -> Self::Output;
}
```

例如，为了能把两个 `Complex<i32>` 值加到一起，`Complex<i32>` 就必须实现`Add<Complex<i32>>`。由于我们想为自身加上同类型的值，因此只需像下面这样编写 Add 即可

```rust
use std::ops::Add;

struct Complex<T> {
  re: T,
  im: T
}

impl Add for Complex<i32> {
  type Output = Complex<i32>
  fn add (self, rhs: Self) -> Self {
    Complex {
      re: self.re + rhs.rs,
      im: self.im + rhs.im
    }
  }
}
```

### 一元运算符

Rust 的所有带符号数值类型都实现了 std::ops::Neg，以支持一元取负运算符 `-`;整数类型和 bool 实现了 std::ops::Not，以支持一元取反运算符 `!`。还有一些是针对这些类型的引用的实现。

> `!` 运算符会对 `bool` 值进行取反，而对整数执行按位取反，它同时扮演着 C 和 C++ 中的 `!` 运算符和 `~` 运算符的角色。

它们的类型定义如下:

```rust
trait Neg {
  type Output;
  fn neg(self) -> Self::Output;
}

trait Not {
  type Output;
  fn not(self) -> Self::Output;
}
```

对一个复数取负就是对它的每个组件取负。以下是对 Complex 值进行取负的泛型实现。

```rust
impl<T> Neg for Complex<T>
where
    T: Neg<Output = T>,
{
    type Output = Complex<T>;
    fn neg(self) -> Self::Output {
        Complex {
            re: -self.re,
            im: -self.im,
        }
    }
}
```
